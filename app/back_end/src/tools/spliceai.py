"""
spliceai_module.py

This module provides functionality to work with SpliceAI, a tool for predicting the
effects of genetic variants on splicing. It includes functions to create VCF files
from variant data, run the SpliceAI tool on these files, parse the results, and
enhance data with SpliceAI evaluation scores.

Functions:
- write_vcf(data: pd.DataFrame) -> str:
    Creates a temporary VCF file from a given DataFrame containing variant information.

- run_spliceai(input_vcf: str, fasta: str, distance: int = 50, annotation: str = "grch38") -> str:
    Executes SpliceAI on the provided VCF file and produces an output VCF file with predictions.

- parse_spliceai_vcf(vcf_file: str) -> list:
    Parses the output VCF file generated by SpliceAI and extracts relevant scores.

- add_spliceai_eval_columns(data: pd.DataFrame, fasta_path: str) -> pd.DataFrame:
    Enhances the provided DataFrame with SpliceAI evaluation columns based on variant predictions.

Custom Exceptions:
- SpliceAIError: Custom exception class for handling errors specific to SpliceAI operations.

Dependencies:
- pandas: For data manipulation and DataFrame handling.
- subprocess: For executing external commands (SpliceAI).
- os: For file path operations and cleanup.
- tempfile: For creating temporary files.

Usage:
To use this module, import it and call the relevant functions, providing the necessary
inputs such as DataFrames containing variant information and paths to required files.

Example:
    import pandas as pd
    from spliceai_module import add_spliceai_eval_columns

    # Load your variant data into a DataFrame
    variant_data = pd.read_csv("variants.csv")

    # Run SpliceAI evaluation
    enhanced_data = add_spliceai_eval_columns(variant_data, "reference.fasta")
"""
import os
import subprocess
import tempfile
import pandas as pd


class SpliceAIError(Exception):
    """Custom exception for SpliceAI errors."""


def write_vcf(data: pd.DataFrame) -> str:
    """
    Writes all variant information into a temporary VCF file.
    This function extracts chromosome and variant information from the
    provided DataFrame and formats it into VCF format, writing it to a
    temporary input VCF file.

    Args:
        data (pd.DataFrame): DataFrame containing variant information,
                             must include 'hg38_gnomad_format' or
                             'variant_id_gnomad' columns.

    Returns:
        str: Path to the temporary VCF file created.
    """
    if 'hg38_gnomad_format' not in data.columns and 'variant_id' not in data.columns:
        raise SpliceAIError("DataFrame must contain 'hg38_gnomad_format' or 'variant_id' column.")

    try:
        with tempfile.NamedTemporaryFile(delete=False, suffix='.vcf') as vcf:
            lines = [
                "##fileformat=VCFv4.2\n",
                "##fileDate=20231001\n",
                "##reference=GRCh38\n"
            ]
            if 'hg38_gnomad_format' in data.columns and 'variant_id_gnomad' in data.columns:
                variant_column = data['hg38_gnomad_format'].combine_first(
                    data['variant_id_gnomad']).fillna('0-0-0-0')
            else:
                variant_column = data['variant_id'].fillna('0-0-0-0')


            chromosomes = variant_column.str.split('-', n=1).str[0].unique()
            lines.extend([f"##contig=<ID={chromosome}>\n" for chromosome in chromosomes])
            lines.append("#CHROM\tPOS\tID\tREF\tALT\tQUAL\tFILTER\tINFO\n")

            split_data = variant_column.str.split('-', expand=True)
            split_data[1] = pd.to_numeric(split_data[1], errors='coerce').fillna(0).astype(int)

            valid_rows = split_data[split_data[3].notna()]

            rows = (
                valid_rows[0] + "\t" +  # CHROM
                valid_rows[1].astype(str) + "\t.\t" +  # POS
                valid_rows[2] + "\t" +  # REF allele
                valid_rows[3] + "\t.\t.\t.\n"  # ALT allele, QUAL, FILTER, INFO
            )
            lines.extend(rows.tolist())
            vcf.write("".join(lines).encode('utf-8'))

            return vcf.name

    except Exception as e:
        raise SpliceAIError(f"Failed to create input VCF file: {e}") from e


def run_spliceai(input_vcf: str, fasta: str, distance=50, annotation="grch38") -> str:
    """
    Runs SpliceAI on the provided VCF file.

    This function constructs and executes a SpliceAI command to analyze
    the variants in the input VCF file and writes the results to a
    temporary output VCF file.

    Args:
        input_vcf (str): Path to the input VCF file.
        fasta (str): Path to the reference genome file in FASTA format.
        distance (int): The distance parameter for SpliceAI (default is 50).
        annotation (str): Annotation type (default is "grch38").

    Returns:
        str: Path to the output VCF file created.

    Raises:
        SpliceAIError: If the FASTA file is not found or if SpliceAI execution fails.
    """
    if not os.path.isfile(fasta):
        raise SpliceAIError(f"FASTA file not found: {fasta}")

    with tempfile.NamedTemporaryFile(delete=False, suffix='.vcf') as output_vcf:
        spliceai_command = [
            "spliceai",
            "-I", input_vcf,
            "-O", output_vcf.name,
            "-R", fasta,
            "-D", str(distance),
            "-A", annotation
        ]

        try:
            result = subprocess.run(spliceai_command, capture_output=True, text=True, check=True)
            if result.returncode != 0:
                raise SpliceAIError(f"SpliceAI failed: {result.stderr}")
            return output_vcf.name  # Return the path to the temporary output VCF file
        except Exception as exc:
            raise SpliceAIError(f"Error running SpliceAI: {exc}") from exc


def parse_spliceai_vcf(vcf_file: str):
    """
    Parses the output VCF file generated by SpliceAI.

    This function extracts the SpliceAI scores from the output VCF file
    and returns them as a list of dictionaries.

    Args:
        vcf_file (str): Path to the VCF file with SpliceAI predictions.

    Returns:
        list: A list of dictionaries containing extracted scores for each variant.

    Raises:
        SpliceAIError: If there is an error while reading or parsing the VCF file.
    """
    spliceai_scores = []
    try:
        with open(vcf_file, 'r',encoding='utf-8') as vcf:
            for line in vcf:
                if line.startswith('#'):
                    continue
                columns = line.strip().split('\t')
                info_field = columns[7]
                if "SpliceAI" in info_field:
                    info_parts = info_field.split(";")
                    for part in info_parts:
                        if part.startswith("SpliceAI="):
                            spliceai_values = part.split("=")[1]
                            delta_scores = spliceai_values.split("|")

                            ds_ag = float(delta_scores[2])
                            ds_al = float(delta_scores[3])
                            ds_dg = float(delta_scores[4])
                            ds_dl = float(delta_scores[5])

                            max_delta_score = max(ds_ag, ds_al, ds_dg, ds_dl)

                            dp_ag = int(delta_scores[6])
                            dp_al = int(delta_scores[7])
                            dp_dg = int(delta_scores[8])
                            dp_dl = int(delta_scores[9])

                            scores = {
                                "Delta score (acceptor gain)": ds_ag,
                                "Delta score (acceptor loss)": ds_al,
                                "Delta score (donor gain)": ds_dg,
                                "Delta score (donor loss)": ds_dl,
                                "Delta position (acceptor gain)": int(columns[1]) + dp_ag,
                                "Delta position (acceptor loss)": int(columns[1]) + dp_al,
                                "Delta position (donor gain)": int(columns[1]) + dp_dg,
                                "Delta position (donor loss)": int(columns[1]) + dp_dl,
                                "Max_Delta_Score": max_delta_score
                            }
                            spliceai_scores.append(scores)
        return spliceai_scores
    except Exception as e:
        raise ValueError(f"Error parsing VCF file {vcf_file}: {e}") from e


def add_spliceai_eval_columns(data: pd.DataFrame, fasta_path: str) -> pd.DataFrame:
    """
    Adds columns for SpliceAI evaluation to the DataFrame with a _spliceai postfix.

    This function orchestrates the VCF writing, SpliceAI execution, and
    parsing of the results to enhance the original DataFrame with SpliceAI
    scores.

    Args:
        data (pd.DataFrame): DataFrame containing original variant information.
        fasta_path (str): Path to the reference genome file in FASTA format.

    Returns:
        pd.DataFrame: DataFrame enriched with SpliceAI evaluation columns.

    Raises:
        SpliceAIError: If any error occurs during the VCF processing or
                        SpliceAI execution.
    """
    data_copy = data.copy()
    input_vcf = write_vcf(data_copy)
    output_vcf = "spliceai_output.vcf"
    try:
        output_vcf = run_spliceai(input_vcf, fasta_path)
        spliceai_scores = parse_spliceai_vcf(output_vcf)

        scores_df = pd.DataFrame(spliceai_scores)
        scores_df.columns = [f"{col}_spliceai" for col in scores_df.columns]
        data_copy = pd.concat([data_copy.reset_index(drop=True),
                               scores_df.reset_index(drop=True)], axis=1)
    finally:
        if os.path.exists(input_vcf):
            os.remove(input_vcf)
        if os.path.exists(output_vcf):
            os.remove(output_vcf)
    return data_copy
